package au.edu.unimelb.boldapp.audio;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.UUID;

import android.media.MediaPlayer;
import android.util.Log;

import au.edu.unimelb.boldapp.FileIO;

/**
 * Class that acts as a proxy to players of the original and respeaking in
 * order to seamlessly play them interleaved
 *
 * @author	Oliver Adams	<oliver.adams@gmail.com>
 * @author	Florian Hanke	<florian.hanke@gmail.com>
 */
public class InterleavedPlayer implements PlayerInterface{

	/**
	 * Player of the original recording
	 */
	private SimplePlayer original;
	
	/**
	 * Player of the respoken recording
	 */
	private SimplePlayer respeaking;

	/**
	 * Indicates whether the audio is currently being played
	 */
	private boolean playing;

	/**
	 * List of the samples in the original on which we are segmenting.
	 */
	private List<Long> originalSegments;

	/**
	 * List of the samples in the respeaking on which we are segmenting.
	 */
	private List<Long> respeakingSegments;

	/**
	 * Standard constructor
	 */
	public InterleavedPlayer(UUID originalUUID, UUID respeakingUUID){
		playing = false;
		original = new SimplePlayer(originalUUID);
		respeaking = new SimplePlayer(respeakingUUID);

		// If the sample rates aren't the same, do something
		if (original.getSampleRate() != respeaking.getSampleRate()) {
			// What exactly, is yet to be decided.
		}

		originalSegments = new ArrayList<Long>();
		respeakingSegments = new ArrayList<Long>();
		// Reading the samples from the mapping file into a list of segments.
		try {
			BufferedReader reader = new BufferedReader(new FileReader(
					FileIO.getAppRootPath() + FileIO.getRecordingsPath() +
					respeakingUUID.toString() + ".map"));
			String line;
			try {
				while ((line = reader.readLine()) != null) {
					String[] lineSplit = line.split(",");
					originalSegments.add(Long.parseLong(lineSplit[0]));
					// If there is a respeaking sample
					if (lineSplit.length == 2) {
						respeakingSegments.add(Long.parseLong(lineSplit[1]));
					}
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Gets the current playback position
	 *
	 * @return	the current position in milliseconds
	 */
	public int getCurrentPosition(){
		return original.getCurrentPosition() + respeaking.getCurrentPosition();
	}

	/**
	 * Returns the sample rate of the file being played, in Hz
	 *
	 * @return	The sample rate of the file being played.
	 */
	public int getSampleRate() {
		// For now assume that all files are 44100Hz.
		return Constants.SAMPLE_RATE;
	}

	/**
	 * Returns the current sample; a pointer to the current location in the
	 * audio file.
	 *
	 * @return	The current sample.
	 */
	 public long getCurrentSample() {
	 	return original.getCurrentSample() + respeaking.getCurrentSample();
	 }

	/**
	 * Checks whether the MediaPlayer is playing.
	 *
	 * @return	true if currently playing, false otherwise
	 */
	public boolean isPlaying(){
		return playing;
	}

	/**
	 * Register a callback to be invoked when the end of the last recoring has
	 * been reached during playback.
	 */
	public void setOnCompletionListener(
			MediaPlayer.OnCompletionListener listener) {
		// If the original has more segments than the respeaking, then it will
		// be the last recording to finish playing, and it should have the
		// onCompletionListener set. Otherwise the respeaking should get it.
		if (originalSegments.length > respeakingSegments.length) {
			original.setOnCompletionListener(listener);
		} else {
			respeaking.setOnCompletionListener(listener);
		}
	}

	public void start() {

	}

	/**
	 * Releases resources associated with this Player.
	 */
	public void release() {
		original.release();
		respeaking.release();
	}

	public void pause(){
	}

	
	public int getDuration(){
		return original.getDuration() + respeaking.getDuration();
	}

	/**
	 * Seeks to the specified time position
	 *
	 * @param	msec	the offset in milliseconds from the start to seek to
	 */
	public void seekTo(int msec){
		long target = timeToSample(msec);
		long total = 0;
		long previous;
		int i;
		for (i = 1; i < originalSegments.length; i++) {
			previous = total;
			total += (originalSegments[i] - originalSegments[i-1]);
			if (total > target) {
				original.seekTo(originalSegments[i-1] + target - previous);
				respeaking.seekTo(respeakingSegments[i-1]);
				return;
			}
			previous = total;
			total += (respeakingSegments[i] - respeakingSegments[i-1]);
			if (total > target) {
				respeaking.seekTo(respeakingSegments[i-1] + target - previous);
				original.seekTo(originalSegments[i]);
				return;
			}
		}
		// If we are here, then i == originalSegments.length
		previous = total;
		total = timeToSample(original.getDuration());
		if (total > target) {
			original.seekTo(originalSegments[i-1] + target - previous);
			respeaking.seekTo(respeakingSegments[i-1]);
			return;
		}
		previous = total;
		total = timeToSample(respeaking.getDuration());
		if (total > target) {
			respeaking.seekTo(respeakingSegments[i-1] + target - previous);
			original.seekTo(originalSegments[i]);
			return;
		}
		original.seekTo(original.getDuration());
		respeaking.seekTo(respeaking.getDuration());
	}

	/**
	 * Converts a time in milliseconds to a sample.
	 *
	 * @returns	The sample corresponding to the supplied time.
	 */
	private long timeToSample(int msec) {
		double sample = msec * (getSampleRate() / (float) 1000);
		return (long) sample;
	}
}
