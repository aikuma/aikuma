File Structure
==============

Goals
-----

Balance between:
- Human readable
- Machine readable

- Well reasoned

Open issues
-----------

- Should recording/user directory names contain more than the uuid?
    - Just the UUIDs are not very human readable.
    - We could add metadata information in the directory, like so:
        - Speaker: andy-<uuid>
        - Recording: andy,peter_the-story-of-the-mountain-<uuid>
    -> We can still extract the uuid data, but it also "speaks" to a user.
        - Problem with the approach: If metadata is changed, the directory name would change.

- Should the mapping of original and respoken segments be in samples, or time (as with the transcriptions)?
    - Time: Resistant to resampling of recordings.
    - Samples: Easier to handle on the machine side (no recalculations necessary).

Overview & Example
------------------

Note that <uuidN> stands for a generated UUID.
uuid1 and uuid1 are the same while uuid1 and uuid2 are different uuids.

/aikuma
    /recordings
        /<uuid1>
            data.wav
            metadata.json
            /transcriptions
                /<uuid4> # It is a simple transcription if the language of the recording is the same as the language of the transcription
                    metadata.json
                    mapping.csv
                /<uuid5> # It is a translation if the language of the recording is different from the language of the transcription
                    metadata.json
                    mapping.csv
        /<uuid2>
            data.wav
            metadata.json
            mapping.csv
            /transcriptions
                /<uuid6>
                    metadata.json
                    mapping.csv
            /images
                /<uuid7>
                    metadata.json
                    image.jpg
                /<uuid8>
                    metadata.json
                    image.jpg
    /speakers
        /<uuid3>
            metadata.json
            image.jpg
        /...
            

uuid1 - recording
uuid2 - commentary on uuid1 (note mapping.csv)
uuid3 - speaker
uuid4 - transcription of uuid1
uuid5 - transcription of uuid1
uuid6 - transcription of uuid2
uuid7 - image for recording uuid2
uuid8 - image for recording uuid2

File structures
---------------

- Generally, open ended, database "record"-like data is stored as CSV (lists).
- Metadata structure which needs to be expanded in the future is stored as JSON (hashes).

This is usually both human-readable and easily processed via machine (and libraries are readily available).


Recording data.wav
------------------

- The data.wav contains only raw data.
- While WAVs can contain additional metadata in XMP format in the INFO chunk, we do not use it as not all applications can handle metadata in WAVs (and may strip it).


Recording metadata.json
-----------------------

- We use JSON hashes, as this enables us to:
    - extend the metadata
    - load "old" versions (applications need to be able to load hashes that might not contain all information)
- However: We do not store hash values that are open ended in size, as that makes the metadata hard to use for humans. Examples of this is the commentary mapping data which is far easier to read in a CSV format.
- If the recording references another recording (i.e. it is a commentary of another), that recording is referenced via "parent_uuid".

Example:
{ "uuid":"<uuid2>", "parent_uuid":"<uuid1>", "languages":["usa","gsw"], "description":"...", "location":"12.3456,-98.7654", "timestamp":"2007-04-05T14:30Z" }

location: Decimal coordinates (http://en.wikipedia.org/wiki/Geographic_coordinate_conversion#Ways_of_writing_coordinates)
timestamp: ISO 8601 (http://en.wikipedia.org/wiki/ISO_8601)


Recording mapping.csv
---------------------

- We use CSV, as it is essentially an open ended list of "records", where a record signifies a mapping between two segments.
- Structure: <orig_start,orig_end,commentary_start,commentary_end>

Example:
0,10000,0,20000
9850,12000,20001,24000
etc.


Transcription mapping.csv
-------------------------

- We use CSV, as it is essentially an open ended list of "records", where a record signifies a mapping between two segments (orig_start,orig_end,commentary_start,commentary_end).
- Structure: <orig_segment_start_time,orig_segment_length,transcription>

Example:
0.000000,4.567890,"Four score and..."
4.567890,2.123456,"hello, world!"
6.691346,1.234567,"Ding!"
etc.


Speaker metadata.json
---------------------

- We use JSON hashes, as this enables us to:
    - extend the metadata
    - load "old" versions (applications need to be able to load hashes that might not contain all information)
- However: We do not store hash values that are open ended in size, as that makes the metadata hard to use for humans.
- If the recording references another recording (i.e. it is a commentary of another), the 

Example:
{ "uuid":"<uuid1>", "languages":["usa","gsw"], "description":"...", "location":"12.3456,-98.7654", "timestamp":"2007-04-05T14:30Z" }

location: Decimal coordinates (http://en.wikipedia.org/wiki/Geographic_coordinate_conversion#Ways_of_writing_coordinates)
timestamp: ISO 8601 (http://en.wikipedia.org/wiki/ISO_8601)






Notes
-----

Prefix Trees
------------

Should the amount of recordings be too large we could relatively easily switch to a structure which uses the first 2 characters of a uuid to create a tree directory structure 2 one level deeper but much less wider:
/abd53... -> /ab/d53...